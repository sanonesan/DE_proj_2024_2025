# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: md_account_d.sql
# pylint: disable-all
import dataclasses
import datetime
from typing import AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.database.schemas.ds import models


CREATE_MD_ACCOUNT = """-- name: create_md_account \\:exec
INSERT INTO
    ds.MD_ACCOUNT_D (
        data_actual_date,
        data_actual_end_date,
        account_rk,
        account_number,
        char_type,
        currency_rk,
        currency_code
    )
VALUES
    (
        :p1,
        :p2,
        :p3,
        :p4,
        :p5,
        :p6,
        :p7
    )
ON CONFLICT (data_actual_date, account_rk) 
DO UPDATE SET
    data_actual_end_date=EXCLUDED.data_actual_end_date,
    account_number=EXCLUDED.account_number,
    char_type=EXCLUDED.char_type,    
    currency_rk=EXCLUDED.currency_rk,
    currency_code=EXCLUDED.currency_code
WHERE NOT (
    ds.MD_ACCOUNT_D.data_actual_end_date=EXCLUDED.data_actual_end_date
    AND ds.MD_ACCOUNT_D.account_number=EXCLUDED.account_number
    AND ds.MD_ACCOUNT_D.char_type=EXCLUDED.char_type
    AND ds.MD_ACCOUNT_D.currency_rk=EXCLUDED.currency_rk
    AND ds.MD_ACCOUNT_D.currency_code=EXCLUDED.currency_code
)
"""


@dataclasses.dataclass()
class CreateMDAccountParams:
    data_actual_date: datetime.date
    data_actual_end_date: datetime.date
    account_rk: int
    account_number: str
    char_type: str
    currency_rk: int
    currency_code: str


CREATE_MD_ACCOUNT_RETURN = """-- name: create_md_account_return \\:one
INSERT INTO
    ds.MD_ACCOUNT_D (
        data_actual_date,
        data_actual_end_date,
        account_rk,
        account_number,
        char_type,
        currency_rk,
        currency_code
    )
VALUES
    (
        :p1,
        :p2,
        :p3,
        :p4,
        :p5,
        :p6,
        :p7
    )
ON CONFLICT (data_actual_date, account_rk) 
DO UPDATE SET
    data_actual_end_date=EXCLUDED.data_actual_end_date,
    account_number=EXCLUDED.account_number,
    char_type=EXCLUDED.char_type,    
    currency_rk=EXCLUDED.currency_rk,
    currency_code=EXCLUDED.currency_code
WHERE NOT (
    ds.MD_ACCOUNT_D.data_actual_end_date=EXCLUDED.data_actual_end_date
    AND ds.MD_ACCOUNT_D.account_number=EXCLUDED.account_number
    AND ds.MD_ACCOUNT_D.char_type=EXCLUDED.char_type
    AND ds.MD_ACCOUNT_D.currency_rk=EXCLUDED.currency_rk
    AND ds.MD_ACCOUNT_D.currency_code=EXCLUDED.currency_code
)
RETURNING data_actual_date, data_actual_end_date, account_rk, account_number, char_type, currency_rk, currency_code
"""


@dataclasses.dataclass()
class CreateMDAccountReturnParams:
    data_actual_date: datetime.date
    data_actual_end_date: datetime.date
    account_rk: int
    account_number: str
    char_type: str
    currency_rk: int
    currency_code: str


GET_MD_ACCOUNTS = """-- name: get_md_accounts \\:many
SELECT
    data_actual_date, data_actual_end_date, account_rk, account_number, char_type, currency_rk, currency_code
FROM
    ds.MD_ACCOUNT_D
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_md_account(self, arg: CreateMDAccountParams) -> None:
        await self._conn.execute(sqlalchemy.text(CREATE_MD_ACCOUNT), {
            "p1": arg.data_actual_date,
            "p2": arg.data_actual_end_date,
            "p3": arg.account_rk,
            "p4": arg.account_number,
            "p5": arg.char_type,
            "p6": arg.currency_rk,
            "p7": arg.currency_code,
        })

    async def create_md_account_return(self, arg: CreateMDAccountReturnParams) -> Optional[models.DsMdAccountD]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_MD_ACCOUNT_RETURN), {
            "p1": arg.data_actual_date,
            "p2": arg.data_actual_end_date,
            "p3": arg.account_rk,
            "p4": arg.account_number,
            "p5": arg.char_type,
            "p6": arg.currency_rk,
            "p7": arg.currency_code,
        })).first()
        if row is None:
            return None
        return models.DsMdAccountD(
            data_actual_date=row[0],
            data_actual_end_date=row[1],
            account_rk=row[2],
            account_number=row[3],
            char_type=row[4],
            currency_rk=row[5],
            currency_code=row[6],
        )

    async def get_md_accounts(self) -> AsyncIterator[models.DsMdAccountD]:
        result = await self._conn.stream(sqlalchemy.text(GET_MD_ACCOUNTS))
        async for row in result:
            yield models.DsMdAccountD(
                data_actual_date=row[0],
                data_actual_end_date=row[1],
                account_rk=row[2],
                account_number=row[3],
                char_type=row[4],
                currency_rk=row[5],
                currency_code=row[6],
            )
