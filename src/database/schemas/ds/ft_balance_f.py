# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: ft_balance_f.sql
# pylint: disable-all
import dataclasses
import datetime
from typing import AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.database.schemas.ds import models


CREATE_BALANCE = """-- name: create_balance \\:exec
INSERT INTO
    ds.FT_BALANCE_F (on_date, account_rk, currency_rk, balance_out)
VALUES
    (:p1, :p2, :p3, :p4)
ON CONFLICT (on_date, account_rk) 
DO UPDATE SET
    currency_rk=EXCLUDED.currency_rk,
    balance_out=EXCLUDED.balance_out
WHERE NOT (
    ds.FT_BALANCE_F.currency_rk=EXCLUDED.currency_rk
    AND ds.FT_BALANCE_F.balance_out=EXCLUDED.balance_out
)
"""


@dataclasses.dataclass()
class CreateBalanceParams:
    on_date: datetime.date
    account_rk: int
    currency_rk: int
    balance_out: Optional[float]


CREATE_BALANCE_RETURN = """-- name: create_balance_return \\:one
INSERT INTO
    ds.FT_BALANCE_F (on_date, account_rk, currency_rk, balance_out)
VALUES
    (:p1, :p2, :p3, :p4)
ON CONFLICT (on_date, account_rk) 
DO UPDATE SET
    currency_rk=EXCLUDED.currency_rk,
    balance_out=EXCLUDED.balance_out
WHERE NOT (
    ds.FT_BALANCE_F.currency_rk=EXCLUDED.currency_rk
    AND ds.FT_BALANCE_F.balance_out=EXCLUDED.balance_out
)
RETURNING on_date, account_rk, currency_rk, balance_out
"""


@dataclasses.dataclass()
class CreateBalanceReturnParams:
    on_date: datetime.date
    account_rk: int
    currency_rk: int
    balance_out: Optional[float]


GET_ACCOUNT_BALANCE = """-- name: get_account_balance \\:many
SELECT
    on_date, account_rk, currency_rk, balance_out
FROM
    ds.FT_BALANCE_F
WHERE ds.FT_BALANCE_F.account_rk = :p1
"""


GET_BALANCE = """-- name: get_balance \\:many
SELECT
    on_date, account_rk, currency_rk, balance_out
FROM
    ds.FT_BALANCE_F
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_balance(self, arg: CreateBalanceParams) -> None:
        await self._conn.execute(sqlalchemy.text(CREATE_BALANCE), {
            "p1": arg.on_date,
            "p2": arg.account_rk,
            "p3": arg.currency_rk,
            "p4": arg.balance_out,
        })

    async def create_balance_return(self, arg: CreateBalanceReturnParams) -> Optional[models.DsFtBalanceF]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_BALANCE_RETURN), {
            "p1": arg.on_date,
            "p2": arg.account_rk,
            "p3": arg.currency_rk,
            "p4": arg.balance_out,
        })).first()
        if row is None:
            return None
        return models.DsFtBalanceF(
            on_date=row[0],
            account_rk=row[1],
            currency_rk=row[2],
            balance_out=row[3],
        )

    async def get_account_balance(self, *, account_rk: int) -> AsyncIterator[models.DsFtBalanceF]:
        result = await self._conn.stream(sqlalchemy.text(GET_ACCOUNT_BALANCE), {"p1": account_rk})
        async for row in result:
            yield models.DsFtBalanceF(
                on_date=row[0],
                account_rk=row[1],
                currency_rk=row[2],
                balance_out=row[3],
            )

    async def get_balance(self) -> AsyncIterator[models.DsFtBalanceF]:
        result = await self._conn.stream(sqlalchemy.text(GET_BALANCE))
        async for row in result:
            yield models.DsFtBalanceF(
                on_date=row[0],
                account_rk=row[1],
                currency_rk=row[2],
                balance_out=row[3],
            )
