# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: md_ledger_account_s.sql
# pylint: disable-all
import dataclasses
import datetime
from typing import AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.database.schemas.ds import models


CREATE_MD_LEDGER_ACCOUNT = """-- name: create_md_ledger_account \\:exec
INSERT INTO ds.MD_LEDGER_ACCOUNT_S (
    chapter,
    chapter_name,
    section_number,
    section_name,
    subsection_name,
    ledger1_account,
    ledger1_account_name,
    ledger_account,
    ledger_account_name,
    characteristic,
    is_resident,
    is_reserve,
    is_reserved,
    is_loan,
    is_reserved_assets,
    is_overdue,
    is_interest,
    pair_account,
    start_date,
    end_date,
    is_rub_only,
    min_term,
    min_term_measure,
    max_term,
    max_term_measure,
    ledger_acc_full_name_translit,
    is_revaluation,
    is_correct
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    :p6,
    :p7,
    :p8,
    :p9,
    :p10,
    :p11,
    :p12,
    :p13,
    :p14,
    :p15,
    :p16,
    :p17,
    :p18,
    :p19,
    :p20,
    :p21,
    :p22,
    :p23,
    :p24,
    :p25,
    :p26,
    :p27,
    :p28
)
ON CONFLICT (ledger_account, start_date)
DO UPDATE SET
    chapter = EXCLUDED.chapter,
    chapter_name = EXCLUDED.chapter_name,
    section_number = EXCLUDED.section_number,
    section_name = EXCLUDED.section_name,
    subsection_name = EXCLUDED.subsection_name,
    ledger1_account = EXCLUDED.ledger1_account,
    ledger1_account_name = EXCLUDED.ledger1_account_name,
    ledger_account_name = EXCLUDED.ledger_account_name,
    characteristic = EXCLUDED.characteristic,
    is_resident = EXCLUDED.is_resident,
    is_reserve = EXCLUDED.is_reserve,
    is_reserved = EXCLUDED.is_reserved,
    is_loan = EXCLUDED.is_loan,
    is_reserved_assets = EXCLUDED.is_reserved_assets,
    is_overdue = EXCLUDED.is_overdue,
    is_interest = EXCLUDED.is_interest,
    pair_account = EXCLUDED.pair_account,
    end_date = EXCLUDED.end_date,
    is_rub_only = EXCLUDED.is_rub_only,
    min_term = EXCLUDED.min_term,
    min_term_measure = EXCLUDED.min_term_measure,
    max_term = EXCLUDED.max_term,
    max_term_measure = EXCLUDED.max_term_measure,
    ledger_acc_full_name_translit = EXCLUDED.ledger_acc_full_name_translit,
    is_revaluation = EXCLUDED.is_revaluation,
    is_correct = EXCLUDED.is_correct
WHERE NOT (
    ds.MD_LEDGER_ACCOUNT_S.chapter = EXCLUDED.chapter
    AND ds.MD_LEDGER_ACCOUNT_S.chapter_name = EXCLUDED.chapter_name
    AND ds.MD_LEDGER_ACCOUNT_S.section_number = EXCLUDED.section_number
    AND ds.MD_LEDGER_ACCOUNT_S.section_name = EXCLUDED.section_name
    AND ds.MD_LEDGER_ACCOUNT_S.subsection_name = EXCLUDED.subsection_name
    AND ds.MD_LEDGER_ACCOUNT_S.ledger1_account = EXCLUDED.ledger1_account
    AND ds.MD_LEDGER_ACCOUNT_S.ledger1_account_name = EXCLUDED.ledger1_account_name
    AND ds.MD_LEDGER_ACCOUNT_S.ledger_account_name = EXCLUDED.ledger_account_name
    AND ds.MD_LEDGER_ACCOUNT_S.characteristic = EXCLUDED.characteristic
    AND ds.MD_LEDGER_ACCOUNT_S.is_resident = EXCLUDED.is_resident
    AND ds.MD_LEDGER_ACCOUNT_S.is_reserve = EXCLUDED.is_reserve
    AND ds.MD_LEDGER_ACCOUNT_S.is_reserved = EXCLUDED.is_reserved
    AND ds.MD_LEDGER_ACCOUNT_S.is_loan = EXCLUDED.is_loan
    AND ds.MD_LEDGER_ACCOUNT_S.is_reserved_assets = EXCLUDED.is_reserved_assets
    AND ds.MD_LEDGER_ACCOUNT_S.is_overdue = EXCLUDED.is_overdue
    AND ds.MD_LEDGER_ACCOUNT_S.is_interest = EXCLUDED.is_interest
    AND ds.MD_LEDGER_ACCOUNT_S.pair_account = EXCLUDED.pair_account
    AND ds.MD_LEDGER_ACCOUNT_S.end_date = EXCLUDED.end_date
    AND ds.MD_LEDGER_ACCOUNT_S.is_rub_only = EXCLUDED.is_rub_only
    AND ds.MD_LEDGER_ACCOUNT_S.min_term = EXCLUDED.min_term
    AND ds.MD_LEDGER_ACCOUNT_S.min_term_measure = EXCLUDED.min_term_measure
    AND ds.MD_LEDGER_ACCOUNT_S.max_term = EXCLUDED.max_term
    AND ds.MD_LEDGER_ACCOUNT_S.max_term_measure = EXCLUDED.max_term_measure
    AND ds.MD_LEDGER_ACCOUNT_S.ledger_acc_full_name_translit = EXCLUDED.ledger_acc_full_name_translit
    AND ds.MD_LEDGER_ACCOUNT_S.is_revaluation = EXCLUDED.is_revaluation
    AND ds.MD_LEDGER_ACCOUNT_S.is_correct = EXCLUDED.is_correct
)
"""


@dataclasses.dataclass()
class CreateMDLedgerAccountParams:
    chapter: Optional[str]
    chapter_name: Optional[str]
    section_number: Optional[int]
    section_name: Optional[str]
    subsection_name: Optional[str]
    ledger1_account: Optional[int]
    ledger1_account_name: Optional[str]
    ledger_account: int
    ledger_account_name: Optional[str]
    characteristic: Optional[str]
    start_date: datetime.date
    end_date: Optional[datetime.date]
    is_resident: Optional[int] = None
    is_reserve: Optional[int] = None
    is_reserved: Optional[int] = None
    is_loan: Optional[int] = None
    is_reserved_assets: Optional[int] = None
    is_overdue: Optional[int] = None
    is_interest: Optional[int] = None
    pair_account: Optional[str] = None
    is_rub_only: Optional[int] = None
    min_term: Optional[str] = None
    min_term_measure: Optional[str] = None
    max_term: Optional[str] = None
    max_term_measure: Optional[str] = None
    ledger_acc_full_name_translit: Optional[str] = None
    is_revaluation: Optional[str] = None
    is_correct: Optional[str] = None


CREATE_MD_LEDGER_ACCOUNT_RETURN = """-- name: create_md_ledger_account_return \\:one
INSERT INTO ds.MD_LEDGER_ACCOUNT_S (
    chapter,
    chapter_name,
    section_number,
    section_name,
    subsection_name,
    ledger1_account,
    ledger1_account_name,
    ledger_account,
    ledger_account_name,
    characteristic,
    is_resident,
    is_reserve,
    is_reserved,
    is_loan,
    is_reserved_assets,
    is_overdue,
    is_interest,
    pair_account,
    start_date,
    end_date,
    is_rub_only,
    min_term,
    min_term_measure,
    max_term,
    max_term_measure,
    ledger_acc_full_name_translit,
    is_revaluation,
    is_correct
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    :p6,
    :p7,
    :p8,
    :p9,
    :p10,
    :p11,
    :p12,
    :p13,
    :p14,
    :p15,
    :p16,
    :p17,
    :p18,
    :p19,
    :p20,
    :p21,
    :p22,
    :p23,
    :p24,
    :p25,
    :p26,
    :p27,
    :p28
)
ON CONFLICT (ledger_account, start_date)
DO UPDATE SET
    chapter = EXCLUDED.chapter,
    chapter_name = EXCLUDED.chapter_name,
    section_number = EXCLUDED.section_number,
    section_name = EXCLUDED.section_name,
    subsection_name = EXCLUDED.subsection_name,
    ledger1_account = EXCLUDED.ledger1_account,
    ledger1_account_name = EXCLUDED.ledger1_account_name,
    ledger_account_name = EXCLUDED.ledger_account_name,
    characteristic = EXCLUDED.characteristic,
    is_resident = EXCLUDED.is_resident,
    is_reserve = EXCLUDED.is_reserve,
    is_reserved = EXCLUDED.is_reserved,
    is_loan = EXCLUDED.is_loan,
    is_reserved_assets = EXCLUDED.is_reserved_assets,
    is_overdue = EXCLUDED.is_overdue,
    is_interest = EXCLUDED.is_interest,
    pair_account = EXCLUDED.pair_account,
    end_date = EXCLUDED.end_date,
    is_rub_only = EXCLUDED.is_rub_only,
    min_term = EXCLUDED.min_term,
    min_term_measure = EXCLUDED.min_term_measure,
    max_term = EXCLUDED.max_term,
    max_term_measure = EXCLUDED.max_term_measure,
    ledger_acc_full_name_translit = EXCLUDED.ledger_acc_full_name_translit,
    is_revaluation = EXCLUDED.is_revaluation,
    is_correct = EXCLUDED.is_correct
WHERE NOT (
    ds.MD_LEDGER_ACCOUNT_S.chapter = EXCLUDED.chapter
    AND ds.MD_LEDGER_ACCOUNT_S.chapter_name = EXCLUDED.chapter_name
    AND ds.MD_LEDGER_ACCOUNT_S.section_number = EXCLUDED.section_number
    AND ds.MD_LEDGER_ACCOUNT_S.section_name = EXCLUDED.section_name
    AND ds.MD_LEDGER_ACCOUNT_S.subsection_name = EXCLUDED.subsection_name
    AND ds.MD_LEDGER_ACCOUNT_S.ledger1_account = EXCLUDED.ledger1_account
    AND ds.MD_LEDGER_ACCOUNT_S.ledger1_account_name = EXCLUDED.ledger1_account_name
    AND ds.MD_LEDGER_ACCOUNT_S.ledger_account_name = EXCLUDED.ledger_account_name
    AND ds.MD_LEDGER_ACCOUNT_S.characteristic = EXCLUDED.characteristic
    AND ds.MD_LEDGER_ACCOUNT_S.is_resident = EXCLUDED.is_resident
    AND ds.MD_LEDGER_ACCOUNT_S.is_reserve = EXCLUDED.is_reserve
    AND ds.MD_LEDGER_ACCOUNT_S.is_reserved = EXCLUDED.is_reserved
    AND ds.MD_LEDGER_ACCOUNT_S.is_loan = EXCLUDED.is_loan
    AND ds.MD_LEDGER_ACCOUNT_S.is_reserved_assets = EXCLUDED.is_reserved_assets
    AND ds.MD_LEDGER_ACCOUNT_S.is_overdue = EXCLUDED.is_overdue
    AND ds.MD_LEDGER_ACCOUNT_S.is_interest = EXCLUDED.is_interest
    AND ds.MD_LEDGER_ACCOUNT_S.pair_account = EXCLUDED.pair_account
    AND ds.MD_LEDGER_ACCOUNT_S.end_date = EXCLUDED.end_date
    AND ds.MD_LEDGER_ACCOUNT_S.is_rub_only = EXCLUDED.is_rub_only
    AND ds.MD_LEDGER_ACCOUNT_S.min_term = EXCLUDED.min_term
    AND ds.MD_LEDGER_ACCOUNT_S.min_term_measure = EXCLUDED.min_term_measure
    AND ds.MD_LEDGER_ACCOUNT_S.max_term = EXCLUDED.max_term
    AND ds.MD_LEDGER_ACCOUNT_S.max_term_measure = EXCLUDED.max_term_measure
    AND ds.MD_LEDGER_ACCOUNT_S.ledger_acc_full_name_translit = EXCLUDED.ledger_acc_full_name_translit
    AND ds.MD_LEDGER_ACCOUNT_S.is_revaluation = EXCLUDED.is_revaluation
    AND ds.MD_LEDGER_ACCOUNT_S.is_correct = EXCLUDED.is_correct
)
RETURNING chapter, chapter_name, section_number, section_name, subsection_name, ledger1_account, ledger1_account_name, ledger_account, ledger_account_name, characteristic, is_resident, is_reserve, is_reserved, is_loan, is_reserved_assets, is_overdue, is_interest, pair_account, start_date, end_date, is_rub_only, min_term, min_term_measure, max_term, max_term_measure, ledger_acc_full_name_translit, is_revaluation, is_correct
"""


@dataclasses.dataclass()
class CreateMDLedgerAccountReturnParams:
    chapter: Optional[str]
    chapter_name: Optional[str]
    section_number: Optional[int]
    section_name: Optional[str]
    subsection_name: Optional[str]
    ledger1_account: Optional[int]
    ledger1_account_name: Optional[str]
    ledger_account: int
    ledger_account_name: Optional[str]
    characteristic: Optional[str]
    start_date: datetime.date
    end_date: Optional[datetime.date]
    is_resident: Optional[int] = None
    is_reserve: Optional[int] = None
    is_reserved: Optional[int] = None
    is_loan: Optional[int] = None
    is_reserved_assets: Optional[int] = None
    is_overdue: Optional[int] = None
    is_interest: Optional[int] = None
    pair_account: Optional[str] = None
    is_rub_only: Optional[int] = None
    min_term: Optional[str] = None
    min_term_measure: Optional[str] = None
    max_term: Optional[str] = None
    max_term_measure: Optional[str] = None
    ledger_acc_full_name_translit: Optional[str] = None
    is_revaluation: Optional[str] = None
    is_correct: Optional[str] = None


GET_MD_LEDGER_ACCOUNT = """-- name: get_md_ledger_account \\:many
SELECT
    chapter, chapter_name, section_number, section_name, subsection_name, ledger1_account, ledger1_account_name, ledger_account, ledger_account_name, characteristic, is_resident, is_reserve, is_reserved, is_loan, is_reserved_assets, is_overdue, is_interest, pair_account, start_date, end_date, is_rub_only, min_term, min_term_measure, max_term, max_term_measure, ledger_acc_full_name_translit, is_revaluation, is_correct
FROM
    ds.MD_LEDGER_ACCOUNT_S
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_md_ledger_account(self, arg: CreateMDLedgerAccountParams) -> None:
        await self._conn.execute(sqlalchemy.text(CREATE_MD_LEDGER_ACCOUNT), {
            "p1": arg.chapter,
            "p2": arg.chapter_name,
            "p3": arg.section_number,
            "p4": arg.section_name,
            "p5": arg.subsection_name,
            "p6": arg.ledger1_account,
            "p7": arg.ledger1_account_name,
            "p8": arg.ledger_account,
            "p9": arg.ledger_account_name,
            "p10": arg.characteristic,
            "p11": arg.is_resident,
            "p12": arg.is_reserve,
            "p13": arg.is_reserved,
            "p14": arg.is_loan,
            "p15": arg.is_reserved_assets,
            "p16": arg.is_overdue,
            "p17": arg.is_interest,
            "p18": arg.pair_account,
            "p19": arg.start_date,
            "p20": arg.end_date,
            "p21": arg.is_rub_only,
            "p22": arg.min_term,
            "p23": arg.min_term_measure,
            "p24": arg.max_term,
            "p25": arg.max_term_measure,
            "p26": arg.ledger_acc_full_name_translit,
            "p27": arg.is_revaluation,
            "p28": arg.is_correct,
        })

    async def create_md_ledger_account_return(self, arg: CreateMDLedgerAccountReturnParams) -> Optional[models.DsMdLedgerAccount]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_MD_LEDGER_ACCOUNT_RETURN), {
            "p1": arg.chapter,
            "p2": arg.chapter_name,
            "p3": arg.section_number,
            "p4": arg.section_name,
            "p5": arg.subsection_name,
            "p6": arg.ledger1_account,
            "p7": arg.ledger1_account_name,
            "p8": arg.ledger_account,
            "p9": arg.ledger_account_name,
            "p10": arg.characteristic,
            "p11": arg.is_resident,
            "p12": arg.is_reserve,
            "p13": arg.is_reserved,
            "p14": arg.is_loan,
            "p15": arg.is_reserved_assets,
            "p16": arg.is_overdue,
            "p17": arg.is_interest,
            "p18": arg.pair_account,
            "p19": arg.start_date,
            "p20": arg.end_date,
            "p21": arg.is_rub_only,
            "p22": arg.min_term,
            "p23": arg.min_term_measure,
            "p24": arg.max_term,
            "p25": arg.max_term_measure,
            "p26": arg.ledger_acc_full_name_translit,
            "p27": arg.is_revaluation,
            "p28": arg.is_correct,
        })).first()
        if row is None:
            return None
        return models.DsMdLedgerAccount(
            chapter=row[0],
            chapter_name=row[1],
            section_number=row[2],
            section_name=row[3],
            subsection_name=row[4],
            ledger1_account=row[5],
            ledger1_account_name=row[6],
            ledger_account=row[7],
            ledger_account_name=row[8],
            characteristic=row[9],
            is_resident=row[10],
            is_reserve=row[11],
            is_reserved=row[12],
            is_loan=row[13],
            is_reserved_assets=row[14],
            is_overdue=row[15],
            is_interest=row[16],
            pair_account=row[17],
            start_date=row[18],
            end_date=row[19],
            is_rub_only=row[20],
            min_term=row[21],
            min_term_measure=row[22],
            max_term=row[23],
            max_term_measure=row[24],
            ledger_acc_full_name_translit=row[25],
            is_revaluation=row[26],
            is_correct=row[27],
        )

    async def get_md_ledger_account(self) -> AsyncIterator[models.DsMdLedgerAccount]:
        result = await self._conn.stream(sqlalchemy.text(GET_MD_LEDGER_ACCOUNT))
        async for row in result:
            yield models.DsMdLedgerAccount(
                chapter=row[0],
                chapter_name=row[1],
                section_number=row[2],
                section_name=row[3],
                subsection_name=row[4],
                ledger1_account=row[5],
                ledger1_account_name=row[6],
                ledger_account=row[7],
                ledger_account_name=row[8],
                characteristic=row[9],
                is_resident=row[10],
                is_reserve=row[11],
                is_reserved=row[12],
                is_loan=row[13],
                is_reserved_assets=row[14],
                is_overdue=row[15],
                is_interest=row[16],
                pair_account=row[17],
                start_date=row[18],
                end_date=row[19],
                is_rub_only=row[20],
                min_term=row[21],
                min_term_measure=row[22],
                max_term=row[23],
                max_term_measure=row[24],
                ledger_acc_full_name_translit=row[25],
                is_revaluation=row[26],
                is_correct=row[27],
            )
